## JS: DOM API

### normalize
Извлеките содержимое тега `<body>` и оберните каждую строку в тег `<p>`. Получившееся тело вставьте обратно. Чтобы получить из содержимого `<body>` независимые строки, нужно разбить тело по переводу строки.

Было:
```
<body>
  one
  two
  three
</body>

```

Стало:
```
<body>
  <p>one</p>
  <p>two</p>
  <p>three</p>
</body>
```

### extractData
Реализуйте и экспортируйте по умолчанию функцию, которая принимает на вход `document.documentElement`, извлекает из него параграфы и возвращает массив из их содержимого.

Пример:
```
const data = extractData(document.documentElement);
console.log(data);
// [
//   'First paragraph'
// ]
```

### extractData2
Реализуйте логику функции, которая принимает на вход document, извлекает из него данные и возвращает объект нужной структуры.

В примере выше "Category Name" - это заголовок категории, "Category Description" - описание категории и две статьи: "Article Name 1" с описанием "Article Description 1" и "Article Name 2" с описанием "Article Description 2".

Нужно сформировать объект, в котором статья описывается следующими свойствами:
* title - заголовок категории
* description - описание категории
* items - статьи

Структура каждой статьи определяется объектом со свойствами:
* title - заголовок статьи (берётся из ссылки статьи)
* description - описание статьи

Пример:
```
const data = extractData(document);
console.log(data);
// {
//   title: 'Category Name',
//   description: 'Category Description',
//   items: [
//     { title: 'Article Name 1', description: 'Article Description 1' },
//     { title: 'Article Name 2', description: 'Article Description 2' }
//   ]
// }
```

### prettify
Реализуйте и экспортируйте функцию по умолчанию, которая находит текст (дочерние текстовые узлы) внутри элемента `<div>` и оборачивает текст в параграф. Переводы строк и отступы изменяться не должны.

Пример:
```
// <body>
//   <p>Boom</p>
//   text
//   <div>Bam</div>
// </body>
prettify(document);
console.log(document.body.innerHTML);
// <body>
//   <p>Boom</p>
//   text
//   <div><p>Bam</p></div>
// </body>
```

### normalize2
Реализуйте и экспортируйте по умолчанию функцию, которая нормализует имена классов для всех элементов на странице. В данном случае это означает, что происходит преобразование всех классов, написанных с использованием `kebab` нотации, в `camelCase` нотацию: `text-center => textCenter`.

Пример:
```
// <body>
//   <div class="text-center row-b">Bam</div>
// </body>
normalize(document);
console.log(document.body.innerHTML);
// <body>
//   <div class="textCenter rowB">Bam</div>
// </body>
```

### app
В этом упражнении нужно реализовать логику добавления алертов по клику на кнопку.
Изначально на странице есть одна кнопка. Вёрстка выглядит так:

```
<button id="alert-generator" class="btn btn-primary">Generate Alert</button>
<div class="alerts m-5"></div>
```

После клика на кнопку, в контейнер с классом alerts добавляется алерт, с названием Alert 1:

```
<div class="alerts m-5">
  <div class="alert alert-primary">Alert 1</div>
</div>
```

Последующий клик добавляет новый алерт сверху:

```
<div class="alerts m-5">
  <div class="alert alert-primary">Alert 2</div>
  <div class="alert alert-primary">Alert 1</div>
</div>
```

Каждый клик добавляет новый алерт, меняя число в его имени.

### app2
Реализуйте логику переключения табов. По клику на таб происходит следующее:
* Класс `active` снимается с текущего элемента меню и активного блока с данными.
* Класс `active` добавляется табу, по которому кликнули и соответствующему блоку с данными.

Сопоставление таба и блока данных идёт по идентификатору, который прописывается в атрибут `data-bs-target` табов. По клику на таб, код должен извлечь `id`, найти соответствующий элемент и сделать его активным, не забыв при этом снять класс `active` с таба и блока, которые были активными до клика.

Постройте свою логику так, чтобы она позволила использовать на одной странице любое количество компонентов nav.

### app3
В задании дана форма обратной связи, состоящая из трех полей: email, name и comment. Напишите и экспортируйте функцию по умолчанию, которая при отправке формы получает из неё данные и экранирует их. Когда форма заполнена и "отправлена" (нажата кнопка send), то вместо формы появляется документ с такой структурой (элемент формы заменяется на другой элемент):

```
<div>
  <p>Feedback has been sent</p>
  <div>Email: test@email.com</div>
  <div>Name: Matz</div>
  <div>Comment: My Comment</div>
</div>
```

### app4
Реализуйте и экспортируйте по умолчанию функцию игры крестики-нолики на поле из 9 ячеек (представлены таблицей). В упражнении дается готовая функция генерации поля. Воспользуйтесь ей для инициализации игры. Поле нужно добавить в тег с классом `.root`.

Затем, по клику, игра ставит поочередно x и o на поле. Подразумевается, что оба игрока играют за одним компьютером и просто кликают по очереди.

Выигрыш в игре никак не отмечается.

### app5
Задача этого упражнения состоит в том, чтобы реализовать автокомплит. На странице присутствуют элементы input, с аттрибутами data-autocomplete и data-autocomplete-name, к которым нужно привязаться. Атрибут data-autocomplete содержит ссылку, по которой нужно делать запрос на данные. Атрибут data-autocomplete-name содержит имя, по которому необходимо найти на странице список ul с точно таким же аттрибутом и значением. В этом списке выводятся данные.

Реализуйте автокомплит.

При изменении строки в поле ввода (ввод символов или их удаление), необходимо выполнить запрос на сервер с query-параметром search, значением которого будет строка введенная в input. Сервер возвращает массив из стран (на английском языке).

Если этот массив не пустой, то нужно заполнить список (посмотреть его нахождение можно либо через public/index.html либо открыв исходный код страницы в веб доступе) таким образом:
```
<ul data-autocomplete-name="country">
  <li>pakistan</li>
  <li>panama</li>
  <li>paraguay</li>
</ul>
```

Если с сервера пришел пустой список, то нужно вывести:
```
<ul data-autocomplete-name="country">
  <li>Nothing</li>
</ul>
```

### progressBar
Реализуйте и экспортируйте по умолчанию функцию, которая запускает код, заполняющий элемент `<progress>` на один процент за 1 секунду. Через 100 секунд процесс должен остановится, так как достигнет максимума.

Начальное состояние:
```
<progress value="0" max="100"></progress>
```

Через одну секунду
```
<progress value="1" max="100"></progress>
```


### PATCH request
Обновить данные в браузере

```
PATCH /comments/3 HTTP/1.1
HOST: hexlet.local
Content-Length: 23
Content-Type: application/json

{ "text": "I got it!" }
```