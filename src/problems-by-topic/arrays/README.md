
## JS: Arrays

### getWeekends
Реализуйте и экспортируйте функцию getWeekends(), которая возвращает массив из двух элементов – названий выходных дней на английском. Функция принимает на вход параметр – формат возврата.

Всего есть два возможных значения:
* 'long' (по умолчанию) – вернётся массив, содержащийзначения saturday и sunday
* 'short' – вернётся массив со значениями sat и sun

```
getWeekends();
// => [ 'saturday', 'sunday' ]
```

### swap
Реализуйте и экспортируйте функцию swap(), которая меняет местами первый и последний элемент массива. Если массив содержит меньше двух элементов, то он возвращается как есть.

```
swap(['one', 'two', 'three']);
// => [ 'three', 'two', 'one' ]
```

### get
Реализуйте и экспортируйте функцию, которая извлекает из массива элемент по указанному индексу, если индекс существует, либо возвращает значение по умолчанию.

Функция принимает на вход три аргумента:
* Массив
* Индекс
* Значение по умолчанию (равно null)

```
const cities = ['moscow', 'london', 'berlin', 'porto'];
get(cities, 7);
// => null
```

### addPrefix
Реализуйте и экспортируйте функцию, которая принимает на вход массив и строковой префикс, и возвращает новый массив, в котором к каждому элементу исходного массива добавляется переданный префикс.

Функция предназначена для работы со строковыми элементами. После префикса должен добавляться пробел.

```
const namesList = ['john', 'smith', 'karl'];
addPrefix(namesList, 'Mr');
// => [ 'Mr john', 'Mr smith', 'Mr karl' ]
```

### reverse
Реализуйте и экспортируйте функцию reverse(), которая принимает на вход массив и располагает элементы исходного массива в обратном порядке.

```
const names = ['john', 'smith', 'karl'];
reverse(names);
// => [ 'karl', 'smith', 'john' ]
```

### calculateSum
Реализуйте и экспортируйте функцию, которая высчитывает сумму всех элементов массива которые делятся без остатка на 3 (три).

```
const coll = [2, 0, 17, 3, 9, 15, 4];
calculateSum(coll);
// => 27
```

### calculateAverage
Реализуйте и экспортируйте функцию, которая высчитывает среднее арифметическое элементов переданного массива.

```
const temperatures = [36, 37.4, 39, 41, 36.6];
calculateAverage(temperatures);
// => 38
```

### getSameParity
Реализуйте функцию getSameParity(), которая принимает на вход массив чисел и возвращает новый, состоящий из элементов, у которых такая же чётность, как и у первого элемента входного массива. Экспортируйте функцию.

```
getSameParity([2, 2, 8, 7, 2]);
// => [ 2, 2, 8, 2 ]
```

### getTotalAmount
Реализуйте и экспортируйте функцию, которая принимает на вход в виде массива кошелёк с деньгами и название валюты и возвращает сумму денег указанной валюты.

Параметры функции:
* массив, содержащий купюры разных валют с различными номиналами,
* наименование валюты.

```
const money = [
  'eur 10',
  'rub 50',
  'eur 5',
  'rub 10',
  'rub 10',
  'eur 100',
  'rub 200',
];
getTotalAmount(money, 'rub');
// => 270
```

### getSuperSeriesWinner
Реализуйте и экспортируйте функцию, которая находит команду победителя для конкретной суперсерии. Победитель определяется как команда, у которой больше побед (не количество забитых шайб) в конкретной серии.

Функция принимает на вход массив, в котором каждый элемент — это массив, описывающий счет в конкретной игре (сколько шайб забила Канада и СССР). Результат функции – название страны: 'canada', 'ussr'. Если суперсерия закончилась в ничью, то нужно вернуть null.

```
// Первое число – сколько забила Канада
// Второе число – сколько забила СССР
const scores = [
  [3, 7], // Первая игра
  [4, 1], // Вторая игра
  [4, 4],
  [3, 5],
  [4, 5],
  [3, 2],
  [4, 3],
  [6, 5],
];

getSuperSeriesWinner(scores); // 'canada'
```

### buildDefinitionList
Реализуйте функцию buildDefinitionList(), которая генерирует HTML список определени (теги `<dl>`, `<dt>` и `<dd>`) и возвращает получившуюся строку. При отсутствии элементов в массиве функция возвращает пустую строку. Экспортируйте функцию по умолчанию.

```
const definitions = [
  ['Блямба', 'Выпуклость, утолщения на поверхности чего-либо'],
  ['Бобр', 'Животное из отряда грызунов'],
];

buildDefinitionList(definitions);
// => '<dl><dt>Блямба</dt><dd>Выпуклость, утолщение на поверхности чего-либо<dd><dt>Бобр</dt><dd>Животное из отряда грызунов</dd></dl>';
```

### makeCensored
Реализуйте и экспортируйте функцию, которая заменяет каждое вхождение указанных слов в предложении на последовательность $#%! и возвращает полученную строку. 

Аргументы:
* текст,
* набор стоп слов.
    
Словом считается любая непрерывная последовательность символов, включая любые спецсимволы (без пробелов).

```
const sentence = 'When you play the game of thrones, you win or you die';
makeCensored(sentence, ['die', 'play']);
// => When you $#%! the game of thrones, you win or you $#%!
```

### getSameCount
Реализуйте и экспортируйте по умолчанию функцию, принимающую на вход два массива и возвращающую количество общих уникальных значений в обоих массивах.

```
getSameCount([], []); // 0
```

### countUniqChars
Реализуйте и экспортируйте по умолчанию функцию, которая получает на вход строку и считает, сколько символов (без учёта повторяющихся символов) спользовано в этой строке. Например, в строке yy используется всего один символ — y. А в строке 111yya! — используется четыре символа: 1, y, a и !.

```
const text = 'yyab';
countUniqChars(text);
// => y, a, b
```

### bubbleSort
Функция сортирует исходный массив coll по возрастанию

```
bubbleSort([3, 2, 10, -2, 0]);
// => [ -2, 0, 2, 3, 10 ]
```

### checkIsBalanced
Реализовать функцию, которая проверяет, что парные скобки сбалансированы. То есть каждая открывающая скобка имеет закрывающую: (), ((()())). А вот пример несбалансированных скобок: (, ((), )(. Для проверки баланса недостаточно считать количество, важен так же порядок в котором они идут.

```
checkIsBalanced('()()()()()()()()())');
// => false
```

### isBracketStructureBalanced
Реализуйте и экспортируйте функцию, которая принимает на вход строку, состоящую только из открывающих и закрывающих скобок разных типов, и проверяет, является ли эта строка сбалансированной. Открывающие и закрывающие скобки должны быть одного вида.
* Пустая строка (отсутствие скобок) считается сбалансированной.
* Скобки — это парные структуры. У каждой открывающей скобки должна быть соответствующая ей закрывающая скобка.
* Скобки должны закрываться в правильном порядке.

```
isBracketStructureBalanced('{<>}}'); // false
```

### getIntersectionOfSortedArrays
Реализуйте и экспортируйте функцию, которая принимает на вход два отсортированных массива и находит их пересечение. Пересечение двух массивов A и B — это массив только с теми элементами A и B, которые одновременно принадлежат обоим массивам, без дублей.

```
const array1 = [10, 11, 24];
const array2 = [10, 13, 14, 18, 24, 30];

getIntersectionOfSortedArrays(array1, array2);
// => [10, 24]
```

### getTheNearestLocation
Реализуйте и экспортируйте функцию getTheNearestLocation(), которая находит ближайшее место к указанной точке на карте и возвращает его.

Параметры функции:
* locations – список мест на карте (массив). Каждое место – массив из двух элементов:
1. Первый элемент – это название места
2. Второй – точка на карте (массив из двух чисел-координат x и y)
* point – текущая точка на карте

```
const locations = [
  ['Park', [10, 5]],
  ['Sea', [1, 3]],
  ['Museum', [8, 4]],
];

const currentPoint = [5, 5];

// Если мест нет, то возвращается null
getTheNearestLocation([], currentPoint); // null
getTheNearestLocation(locations, currentPoint); // ['Museum', [8, 4]]
```

### getMax
Реализуйте и экспортируйте функцию getMax(), которая ищет в массиве максимальное значение и возвращает его.

```
getMax([1, 10, 8]);
// => 10
```

### flatten
Реализуйте и экспортируйте функцию flatten(). Эта функция принимает на вход массив и выпрямляет его: если элементами массива являются массивы, то flatten сводит всё к одному массиву, раскрывая один уровень вложенности.

```
flatten([1, [[2], [3]], [9]]);
// => [1, [2], [3], 9]
```

### getLastWordLength
Реализуйте и экспортируйте по умолчанию функцию, которая возвращает длину последнего слова переданной на вход строки. Словом считается любаяпоследовательность, не содержащая пробелов.

```
getLastWordLength('hello, world!  '); // 6
```

### summaryRanges
Реализуйте и экспортируйте по умолчанию функцию, которая находит в массиве непрерывные возрастающие последовательности чисел и возвращает массив с их перечислением.

```
summaryRanges([110, 111, 112, 111, -5, -4, -2, -3, -4, -5]);
// ['110->112', '-5->-4']
```

### getLongestLength
Реализуйте функцию getLongestLength(), принимающую на вход строку и возвращающую длину максимальной последовательности из неповторяющихся символов. Подстрока может состоять из одного символа. Например в строке qweqrty, можно выделить следующие подстроки: qwe, weqrty. Самой длинной будет weqrty.


```
getLongestLength('abcdeef'); // 5
getLongestLength('1234561qweqwerqer'); // 9
getLongestLength(''); // 0
```

### buildSnailPath
Реализуйте и экспортируйте по умолчанию функцию, которая принимает на вход матрицу и возвращает список элементов матрицы по порядку следования от левого верхнего элемента по часовой стрелке к внутреннему.

```
buildSnailPath([
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9, 10, 11, 12],
]); // [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] 

buildSnailPath([
  [undefined, '', null],
  [true, false, 'foo'],
  [[], {}, { key: 'bar' }],
]); // [undefined, '', null, 'foo', { key: 'bar' }, {}, [], true, false]
```