## JS: Asynchronous programming

### printer
Реализуйте и экспортируйте по умолчанию асинхронную функцию, которая читает данные файла по указанному пути и выводит их в консоль.

```
print('./myfile');
```

### writer
Реализуйте асинхронную функцию, которая записывает данные по указанному пути и оповещает о завершении работы через переданный колбек. Экспортируйте функцию по умолчанию.

```
write('./myfile', 'data', () => {
  console.log('success');
});
```

### compareFileSizes
Реализуйте и экспортируйте асинхронную функцию compareFileSizes(), которая сравнивает размеры двух файлов и передает результат сравнения в переданную callback-функцию. Если первый файл больше второго, то она передает единицу, если размеры равны, то ноль, иначе — -1.

```
compareFileSizes('filepath1', 'filepath2', (_err, result) => console.log(result));
```

### move
Реализуйте и экспортируйте функцию move, которая асинхронно перемещает файл из одного места в другое. Ее параметры:
* Путь до файла исходника
* Путь по которому нужно копировать файл
* Колбек, у которого единственный аргумент — ошибка.

Алгоритм работы функции следующий:
1. Читаем исходный файл
2. Создаём новый файл и записываем туда данные исходного файла (это важно сделать до попытки удаления исходного файла!)
3. Удаляем исходный файл
Реальная функция move устроена не так. Если исходник и приемник находятся на одном устройстве, то копирования не происходит, меняются лишь указатели в фс

```
move('/opt/myfile', '/tmp/newfile', (error) => {
  if (error) {
    console.log('oops');
    return;
  }
  console.log('yes!');
});
```

### getDirectorySize
Реализуйте и экспортируйте асинхронную функцию getDirectorySize(), которая считает размер переданной директории не включая поддиректории. Анализ размера файла должен происходить параллельно, для этого воспользуйтесь библиотекой async.

Пример:
```
getDirectorySize('/usr/local/bin', (err, size) => {
  console.log(size);
});
```

### watch
Реализуйте и экспортируйте по умолчанию асинхронную функцию, которая следит за изменением файла с заданной периодичностью. Функция должна возвращать идентификатор таймера, запущенного внутри.

Если файл был изменён со времени предыдущей проверки, то необходимо вызвать колбек. Если во время анализа файла (через `fs.stat`) произошла ошибка, то нужно остановить таймер и вызвать колбек, передав туда ошибку.

Отслеживание изменений файла должно начинаться с момента вызова функции. Параметры функции:
* Путь до файла, который нужно отслеживать
* Период отслеживания
* Колбек, принимающий аргументом ошибку

Пример:
```
const id = watch(filepath, 500, (err) => {
  console.log('Wow!');
});
 
setTimeout(() => fs.appendFileSync(filepath, 'ehu'), 700);
setTimeout(() => clearInterval(id), 5000); // остановить отслеживание через 5 секунд

```

### reverse
Реализуйте и экспортируйте асинхронную функцию reverse(), которая изменяет порядок расположения строк в файле на обратный. Функция должна перезаписать файл.

```
# file.txt
one
two
```

```
import { reverse } from './file.js';
 
reverse('file.txt');
// two
// one
```

### touch
Реализуйте и экспортируйте асинхронную функцию touch(), которая создаёт файл, если его не существует. Если файл существует, то функция должна успешно завершиться.

```
import { touch } from './file.js';
 
touch('/myfile').then(() => console.log('created!'));
 
// Повторный вызов успешно завершается
touch('/myfile').then(() => console.log('created!'));

```

Подсказка:
* fsPromises.access — проверка существования файла

### getTypes
Реализуйте и экспортируйте асинхронную функцию getTypes(), которая анализирует список переданных путей и возвращает массив (в промисе), с описанием того, что находится по каждому из путей в виде строк 'directory' и 'file'.

Эта функция должна отрабатывать успешно в любом случае. Если во время выполнения асинхронной операции возникла ошибка, то значением для этого пути будет null. Для простоты считаем, что в эту функцию всегда передается как минимум один путь для обработки.

Пример:
```
getTypes(['/etc', '/etc/hosts', '/undefined']).then(console.log);
// ['directory', 'file', null]
```

Подсказки
* fsPromises.stat - информация о файле или директории. Для проверки на директорию используйте метод isDirectory.
* Методы then и catch не меняют сам промис, а возвращают новый

### getDirectorySize2
Реализуйте и экспортируйте асинхронную функцию getDirectorySize(), которая считает размер переданной директории (не включая поддиректории).

```
import { getDirectorySize } from './file.js';
 
getDirectorySize('/usr/local/bin').then(console.log);
```

Подсказка
* fsPromises.readdir - чтение содержимого директории
* path.join - конструирует пути
* fsPromises.stat - информация о файле
* _.sumBy - нахождение суммы в массиве

### wait
Реализуйте таймер в виде промиса. Функция должна принимать на вход количество миллисекунд и возвращать промис.

Пример:
```
wait(100).then(() => console.log('time is over!'));
```

### exchange
Реализуйте и экспортируйте асинхронную функцию exchange(), которая обменивает содержимое двух файлов.

Пример:
```
exchange('/myfile1', '/myfile2');
```


### getBadLinks
Реализуйте и экспортируйте по умолчанию функцию, которая принимает на вход ссылку на страницу какого-то сайта, загружает содержимое этой страницы, извлекает из него ссылки и проверяет их доступность. Функция должна вернуть список битых ссылок. Любые ссылки возвращающие коды ответа кроме 2xx (любые двухсотые) считаются битыми.

Пример:
```
const url = 'https://privet.hexlet';
const links = await getBadLinks(url);
console.log(links);
// Гипотетический пример:
// [
//   'https://privet.hexlet/somepage',
//   'https://privet.hexlet/another/page',
// ]
```

Подсказки
* Для извлечения ссылок со страницы воспользуйтесь функцией extractLinks(content)

### promisify
Реализуйте и экспортируйте по умолчанию функцию, которая "промисифицирует" асинхронные функции с колбеками.

```
const readFile = promisify(fs.readFile);
const writeFile = promisify(fs.writeFile);
 
const filepath = '/tmp/myfile';
 
writeFile(filepath, 'content')
  .then(() => readFile(filepath))
  .then(console.log);
```

Реализация этой функции опирается на тот факт, что колбек в асинхронных функциях всегда передается последним параметром.

Подсказка
* Вам понадобятся rest и spread операторы

### ls
Реализуйте и экспортируйте по умолчанию функцию, которая принимает на вход путь (абсолютный или относительный) и возвращает информацию о файлах и директориях, расположенных по этому пути. Данные возвращаются в виде массива объектов, где каждый элемент — это информация о конкретном файле: его путь и описание доступов (stat.mode). Объекты в массиве должны быть отсортированы по имени файла.

```
import ls from '../ls.js';
 
await ls('/var');
// [
//   { filepath: '/var/local', mode: 17917 },
//   { filepath: '/var/lock', mode: 17407 },
//   { filepath: '/var/log', mode: 16877 },
// ];
 
await ls('/etc/passwd');
// [{ filepath: '/etc/passwd', mode: 33188 }];
 
await ls('../../../../etc/passwd');
// [{ filepath: '/etc/passwd', mode: 33188 }];
```

Эта функция должна уметь обрабатывать не только директории, но и файлы. В таком случае отдается массив с одним объектом — информацией по текущему файлу.

Подсказки
* readdir() — чтение директории
* stat() — информация о файле. isFile() — является ли файлом, mode - описание доступа.
* zipWith() — вспомогательная функция из lodash.