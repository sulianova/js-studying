## JS: Data abstractions

### calculateDistance
Реализуйте и экспортируйте по умолчанию функцию, которая находит расстояние между двумя точками на плоскости:

```
point1 = [0, 0];
point2 = [3, 4];
calculateDistance(point1, point2); // 5
```

### getMidpoint
Реализуйте и экспортируйте по умолчанию функцию, которая находит точку посередине между двумя указанными точками.

```
const point1 = { x: 0, y: 0 };
const point2 = { x: 4, y: 4 };
const point3 = getMidpoint(point1, point2);
console.log(point3); // => { x: 2, y: 2 };
```

### segments
Реализуйте и экспортируйте указанные ниже функции:
* makeSegment(). Принимает на вход две точки и возвращает отрезок.
* getBeginPoint(). Принимает на вход отрезок и возвращает точку начала отрезка.
* getEndPoint(). Принимает на вход отрезок и возвращает точку конца отрезка.
* getMidpointOfSegment(). Принимает на вход отрезок и возвращает точку находящуюся на середине отрезка.

### points
В этой задаче тесты написаны для отрезков, которые, в свою очередь, используют точки. Ваша задача — реализовать интерфейсные функции для работы с точками. Внутреннее представление точек должно быть основано на полярной системе координат, хотя интерфейс предполагает работу с декартовой системой (снаружи). Для обозначения координат используются целые числа.

Реализуйте интерфейсные функции точек:
* getX(point)
* getY(point)
makePoint(x, y). Принимает на вход координаты и возвращает точку. Уже реализован.

```
const x = 4;
const y = 8;
 
// point хранит в себе данные в полярной системе координат
const point = makePoint(x, y);
 
// Здесь происходит преобразование из полярной в декартову
getX(point); // 4
getY(point); // 8
```

Подсказки:
* Трансляция декартовых координат в полярные была описана в теории
* Получить x можно по формуле radius * cos(angle)
* Получить y можно по формуле radius * sin(angle)
* Результат вычислений необходимо округлить к ближайшему целому (согласно правилам математического округления)

### rectangle
Реализуйте абстракцию (набор функций) для работы с прямоугольниками, стороны которого всегда параллельны осям. Прямоугольник может располагаться в любом месте координатной плоскости.

При такой постановке, достаточно знать только три параметра для однозначного задания прямоугольника на плоскости: координаты левой верхней точки, ширину и высоту. Зная их, мы всегда можем построить прямоугольник одним единственным способом.

Основной интерфейс:
* makeRectangle(point, width, height) (конструктор) – создает прямоугольник. Принимает параметры: левую-верхнюю точку, ширину и высоту. Ширина и высота – положительные числа.
* Селекторы getStartPoint(rectangle), getWidth(rectangle) и getHeight(rectangle)
* containsOrigin(rectangle) – проверяет, принадлежит ли центр координат прямоугольнику (не лежит на границе прямоугольника, а находится внутри). Чтобы в этом убедиться, достаточно проверить, что все вершины прямоугольника лежат в разных квадрантах (их можно высчитать в момент проверки).

Экспортируйте функции makeRectangle(point, width, height) и containsOrigin(rectangle).

```
// Создание прямоугольника:
// p - левая верхняя точка
// 4 - ширина
// 5 - высота
//
// p    4
// -----------
// |         |
// |         | 5
// |         |
// -----------

p = makeDecartPoint(0, 1);
rectangle = makeRectangle(p, 4, 5);

containsOrigin(rectangle); // false

rectangle2 = makeRectangle(makeDecartPoint(-4, 3), 5, 4);
containsOrigin(rectangle2); // true
```

Подкасказки:
* Квадрант плоскости — любая из 4 областей (углов), на которые плоскость делится двумя взаимно перпендикулярными прямыми, принятыми в качестве осей координат.

### rational
Реализуйте абстракцию для работы с рациональными числами, включающую в себя следующие функции:
* Конструктор makeRational() - принимает на вход числитель и знаменатель, возвращает дробь в виде объекта.
* Селектор getNumer() - возвращает числитель
* Селектор getDenom() - возвращает знаменатель
* Сложение add() - складывает переданные дроби
* Вычитание sub() - находит разность между двумя дробями
Не забудьте реализовать нормализацию дробей удобным для вас способом.

```
const rat1 = makeRational(3, 9);
getNumer(rat1); // 1
getDenom(rat1); // 3
 
const rat2 = makeRational(10, 3);
 
const rat3 = add(rat1, rat2);
ratToString(rat3); // '11/3'
 
const rat4 = sub(rat1, rat2);
ratToString(rat4); // '-3/1'
```

### url
Реализуйте абстракцию для работы с урлами. Она должна извлекать и менять части адреса.

Интерфейс:
* make(url) - Конструктор. Создает урл.

* setProtocol(data, protocol) - Сеттер. Меняет схему.
* getProtocol(data) - Селектор (геттер). Извлекает схему.

* setHost(data, host) - Сеттер. Меняет хост.
* getHost(data) - Геттер. Извлекает хост.

* setPath(data, path) - Сеттер. Меняет строку запроса.
* getPath(data) - Геттер. Извлекает строку запроса.

* setQueryParam(data, key, value) - Сеттер. Устанавливает значение для параметра запроса.
* getQueryParam(data, paramName, default = null) - Геттер. Извлекает значение для параметра запроса. Третьим параметром функция принимает значение по умолчанию, которое возвращается тогда, когда в запросе не было такого параметра

* toString(data) - Геттер. Преобразует урл в строковой вид.

```
const url = make('https://hexlet.io/community?q=low');
 
setProtocol(url, 'http:');
toString(url); // 'http://hexlet.io/community?q=low'
 
setPath(url, '/404');
toString(url); // 'http://hexlet.io/404?q=low'
 
setQueryParam(url, 'page', 5);
toString(url); // 'http://hexlet.io/404?q=low&page=5'
 
setQueryParam(url, 'q', 'high');
toString(url); // 'http://hexlet.io/404?q=high&page=5'
```

Подкасказки:
Используйте стандартный объект URL для работы с адресами: URL
Методы set() и get()