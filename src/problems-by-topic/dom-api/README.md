## JS: DOM API

### normalize
Извлеките содержимое тега `<body>` и оберните каждую строку в тег `<p>`. Получившееся тело вставьте обратно. Чтобы получить из содержимого `<body>` независимые строки, нужно разбить тело по переводу строки.

Было:
```
<body>
  one
  two
  three
</body>

```

Стало:
```
<body>
  <p>one</p>
  <p>two</p>
  <p>three</p>
</body>
```

Подсказки
* Доступ к содержимому тега <body> выполняется через свойство document.body.innerHTML. Из него можно читать и в него можно писать.
* Лишние пробелы и переводы строк удаляются с помощью метода trim()

### extractData
Реализуйте и экспортируйте по умолчанию функцию, которая принимает на вход `document.documentElement`, извлекает из него параграфы и возвращает массив из их содержимого.

Пример:
```
const data = extractData(document.documentElement);
console.log(data);
// [
//   'First paragraph'
// ]
```

### extractData2
Реализуйте логику функции, которая принимает на вход document, извлекает из него данные и возвращает объект нужной структуры.

В примере выше "Category Name" - это заголовок категории, "Category Description" - описание категории и две статьи: "Article Name 1" с описанием "Article Description 1" и "Article Name 2" с описанием "Article Description 2".

Нужно сформировать объект, в котором статья описывается следующими свойствами:
* title - заголовок категории
* description - описание категории
* items - статьи

Структура каждой статьи определяется объектом со свойствами:
* title - заголовок статьи (берётся из ссылки статьи)
* description - описание статьи

Пример:
```
const data = extractData(document);
console.log(data);
// {
//   title: 'Category Name',
//   description: 'Category Description',
//   items: [
//     { title: 'Article Name 1', description: 'Article Description 1' },
//     { title: 'Article Name 2', description: 'Article Description 2' }
//   ]
// }
```

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <script type="module" src="/extractor.js" defer></script>
    <script type="module" src="/index.js" defer></script>
  </head>
  <body>
    <div class="content">
      <h1>Category Name</h1>
      <div class="description">Category Description</div>
      <div class="links">
        <div>
          <h2><a href="#">Article Name 1</a></h2>
          <p>Article Description 1</p>
        </div>
        <div>
          <h2><a href="#">Article Name 2</a></h2>
          <p>Article Description 2</p>
        </div>
      </div>
    </div>
  </body>
</html>
```

### prettify
Реализуйте и экспортируйте функцию по умолчанию, которая находит текст (дочерние текстовые узлы) внутри элемента `<div>` и оборачивает текст в параграф. Переводы строк и отступы изменяться не должны.

Пример:
```
// <body>
//   <p>Boom</p>
//   text
//   <div>Bam</div>
// </body>
prettify(document);
console.log(document.body.innerHTML);
// <body>
//   <p>Boom</p>
//   text
//   <div><p>Bam</p></div>
// </body>
```

Алгоритм
* Выберите все нужные узлы по тегу
* Обойдите каждый выбранный узел, найдите в его дочерних узлах (childNodes) текстовые узлы и замените их на новые узлы, содержащие тег <p>.

Подсказки
* Очистка строки от пробельных символов: trim
* Замена узлов node.replaceWith()
* Проверка текстовых узлов: node instanceof Text

### normalize2
Реализуйте и экспортируйте по умолчанию функцию, которая нормализует имена классов для всех элементов на странице. В данном случае это означает, что происходит преобразование всех классов, написанных с использованием `kebab` нотации, в `camelCase` нотацию: `text-center => textCenter`.

Пример:
```
// <body>
//   <div class="text-center row-b">Bam</div>
// </body>
normalize(document);
console.log(document.body.innerHTML);
// <body>
//   <div class="textCenter rowB">Bam</div>
// </body>
```

Подсказки
* Самый простой способ найти все элементы в документе это document.body.getElementsByTagName('*')
* Приведение к camelCase https://lodash.com/docs#camelCase
* Замена классов replace у объекта classList

### app
В этом упражнении нужно реализовать логику добавления алертов по клику на кнопку.
Изначально на странице есть одна кнопка. Вёрстка выглядит так:

```
<button id="alert-generator" class="btn btn-primary">Generate Alert</button>
<div class="alerts m-5"></div>
```

После клика на кнопку, в контейнер с классом alerts добавляется алерт, с названием Alert 1:

```
<div class="alerts m-5">
  <div class="alert alert-primary">Alert 1</div>
</div>
```

Последующий клик добавляет новый алерт сверху:

```
<div class="alerts m-5">
  <div class="alert alert-primary">Alert 2</div>
  <div class="alert alert-primary">Alert 1</div>
</div>
```

Каждый клик добавляет новый алерт, меняя число в его имени.

Реализуйте и установите обработчик события click на кнопке в соответствии с логикой выше.

Подсказки
* Саму кнопку можно получить в коде через ее id
* После выполнения задания, подумайте над тем, как добавить возможность скрывать алерты.
* Поэкспериментируйте с отладкой в этом упражнении, опирайтесь на наш гайд, чтобы разобраться с тестами

### app2
Реализуйте логику переключения табов. По клику на таб происходит следующее:
* Класс `active` снимается с текущего элемента меню и активного блока с данными.
* Класс `active` добавляется табу, по которому кликнули и соответствующему блоку с данными.

Сопоставление таба и блока данных идёт по идентификатору, который прописывается в атрибут `data-bs-target` табов. По клику на таб, код должен извлечь `id`, найти соответствующий элемент и сделать его активным, не забыв при этом снять класс `active` с таба и блока, которые были активными до клика.

Постройте свою логику так, чтобы она позволила использовать на одной странице любое количество компонентов nav.

Подсказки
* В коде можно использовать глобальный объект document
* Селектор по data элементам [data-toggle], например: document.querySelectorAll('h1[data-key]');
* Получить необходимый data-атрибут можно через dataset
* Постарайтесь не завязываться на конкретные идентификаторы и элементы
* Если вы используете другой метод извлечения списка, например document.getElementsByClassName(), то обратите внимание, что он возвращает HTMLCollection, а не NodeList. HTMLCollection не поддерживает метод forEach(), однако вы можете привести такой список к массиву, например используя Array.from()
* Переключение должно работать на любой реализации: с использованием button и на div

### app3
В задании дана форма обратной связи, состоящая из трех полей: email, name и comment. Напишите и экспортируйте функцию по умолчанию, которая при отправке формы получает из неё данные и экранирует их. Когда форма заполнена и "отправлена" (нажата кнопка send), то вместо формы появляется документ с такой структурой (элемент формы заменяется на другой элемент):

```
<div>
  <p>Feedback has been sent</p>
  <div>Email: test@email.com</div>
  <div>Name: Matz</div>
  <div>Comment: My Comment</div>
</div>
```

### app4
Реализуйте и экспортируйте по умолчанию функцию игры крестики-нолики на поле из 9 ячеек (представлены таблицей). В упражнении дается готовая функция генерации поля. Воспользуйтесь ей для инициализации игры. Поле нужно добавить в тег с классом `.root`.

Затем, по клику, игра ставит поочередно x и o на поле. Подразумевается, что оба игрока играют за одним компьютером и просто кликают по очереди.

Выигрыш в игре никак не отмечается.

### app5
Задача этого упражнения состоит в том, чтобы реализовать автокомплит. На странице присутствуют элементы input, с аттрибутами data-autocomplete и data-autocomplete-name, к которым нужно привязаться. Атрибут data-autocomplete содержит ссылку, по которой нужно делать запрос на данные. Атрибут data-autocomplete-name содержит имя, по которому необходимо найти на странице список ul с точно таким же аттрибутом и значением. В этом списке выводятся данные.

Реализуйте автокомплит.

При изменении строки в поле ввода (ввод символов или их удаление), необходимо выполнить запрос на сервер с query-параметром search, значением которого будет строка введенная в input. Сервер возвращает массив из стран (на английском языке).

Если этот массив не пустой, то нужно заполнить список (посмотреть его нахождение можно либо через public/index.html либо открыв исходный код страницы в веб доступе) таким образом:
```
<ul data-autocomplete-name="country">
  <li>pakistan</li>
  <li>panama</li>
  <li>paraguay</li>
</ul>
```

Если с сервера пришел пустой список, то нужно вывести:
```
<ul data-autocomplete-name="country">
  <li>Nothing</li>
</ul>
```

### app6
В Bootstrap есть компонент Carousel. Этот слайдер устроен так же как и всё остальное в бутстрапе. В верстке определяются data аттрибуты, по которым бутстрап понимает что это карусель и оживляет ее.

На слайдере отображаются две стрелки, одна влево другая вправо. Клики по этим стрелкам приводят к перемотке слайдов по кругу. Если слайды заканчиваются, то происходит переход от конца к началу или наоборот. С точки зрения DOM происходит следующее:
* Класс active снимается с текущего элемента .carousel-item
* Активный элемент получает класс active

Реализуйте логику слайдера в функции экспортированной по умолчанию.

Постройте свою логику так, чтобы она позволила использовать на одной странице любое количество компонентов carousel с любым количеством картинок внутри.

Решите задачу, используя методы jQuery.

Подсказки
* Изучите документацию для работы с коллекциями, поиском и изменением атрибутов. Например, методы для работы с классами: removeClass(), addClass()
* Кроме того, вам могут понадобиться следующие методы взаимодействия с DOM: next(), prev(), first(), last() и siblings()

### progressBar
Реализуйте и экспортируйте по умолчанию функцию, которая запускает код, заполняющий элемент `<progress>` на один процент за 1 секунду. Через 100 секунд процесс должен остановится, так как достигнет максимума.

Начальное состояние:
```
<progress value="0" max="100"></progress>
```

Через одну секунду
```
<progress value="1" max="100"></progress>
```


### PATCH request
Обновить данные в браузере

```
PATCH /comments/3 HTTP/1.1
HOST: hexlet.local
Content-Length: 23
Content-Type: application/json

{ "text": "I got it!" }
```