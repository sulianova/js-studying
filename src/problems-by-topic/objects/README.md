## JS: Objects

### normalize
Реализуйте и экспортируйте по умолчанию функцию, которая "нормализует" данные переданного урока. То есть приводит их к определенному виду. Нормализация происходит путём изменения исходного объекта.

Функция должна обновлять содержимое урока по следующим правилам:
* Имя капитализируется.
* Весь текст описания приводится к нижнему регистру.

```
const lesson = {
  name: 'ДеструКТУРИЗАЦИЯ',
  description: 'каК удивитЬ друзей',
};

normalize(lesson);
// => { name: 'Деструктуризация', description: 'как удивить друзей' }
```

### is
Реализуйте и экспортируйте по умолчанию функцию, которая сравнивает объекты по совпадению данных, а не по ссылкам. Эта функция принимает на вход две компании и возвращает true, если их структура одинаковая, и false в обратном случае. Проверка должна проходить по свойствам name, state, website.

```
const company1 = {
  name: 'Hexlet',
  state: 'moderating',
  website: 'https://hexlet.io',
};
const company2 = {
  name: 'CodeBasics',
  state: 'published',
  website: 'https://code-basics.com',
};

is(company1, company2);
// => false
```

### getDomainInfo
Реализуйте и экспортируйте по умолчанию функцию, которая принимает на вход имя сайта и возвращает информацию о нем. Если домен передан без указания протокола, то по умолчанию берется http

```
getDomainInfo('https://hexlet.io');
// => { scheme: 'https', name: 'hexlet.io' }
```

### countWords
Реализуйте и экспортируйте по умолчанию функцию, которая считает количество слов в предложении, и возвращает объект. В объекте свойства — это слова (приведенные к нижнему регистру), а значения — это то, сколько раз слово встретилось в предложении. Слова в предложении могут находиться в разных регистрах. Перед подсчетом их нужно приводить в нижний регистр, чтобы не пропускались дубли.

```
const text1 = 'another one sentence with strange Words words';

countWords(text1);
// => { another: 1, one: 1, sentence: 1, with: 1, strange: 1, words: 2 }
```

### pick
Реализуйте и экспортируйте функцию, которая формирует из переданного объекта другой объект, включающий только указанные свойства. Параметры:
* Исходный объект
* Массив имен свойств

```
const data2 = {
  user: 'ubuntu',
  cores: 4,
  os: 'linux',
};

pick(data2, ['user']); // { user: 'ubuntu' }
```

### get
Реализуйте и экспортируйте функцию, которая извлекает из объекта любой глубины вложенности значение по указанным ключам. Параметры:
* исходный объект
* цепочка ключей (массив), по которой ведётся поиск значения
В случае, когда добраться до значения невозможно, возвращается null.

```
const data3 = {
  user: 'ubuntu',
  hosts: {
    0: {
      name: 'web1',
    },
    1: {
      name: 'web2',
      null: 3,
      active: false,
    },
  },
};

get(data3, ['user', 'ubuntu']); // null
get(data3, ['hosts', 1, 'name']); // 'web2'
get(data3, ['hosts', 0]); // { name: 'web1' }
```

Альтернатива get в библиотеке lodash:

```
import _ from 'lodash';

const obj = {};
const value = _.get(obj, 'one.two.three', 'defaultValue'); // 'defaultValue'
```

### fill
Реализуйте и экспортируйте по умолчанию функцию, которая заполняет объект данными из другого объекта по разрешенному списку ключей. Параметры:
* Исходный объект
* Список ключей которые нужно заменить
* Данные, которые нужно сливать в исходный объект
В случае, когда список ключей пустой, нужно сливать все данные полностью.

```
const company3 = {
  name: null,
  state: 'moderating',
};

const data = {
  name: 'Hexlet',
  state: 'published',
};

fill(company3, ['name'], data);
// {
//   name: 'Hexlet',
//   state: 'moderating',
// }
```

### cloneDeep
Реализуйте и экспортируйте функцию, которая выполняет глубокое копирование объектов.

### make
Реализуйте и экспортируйте по умолчанию функцию, которая создает объект компании и возвращает его. Для создания компании обязательно только одно свойство – имя компании. Остальные свойства добавляются только если они есть. Параметры:
* Имя
* Объект с дополнительными свойствами
Также у компаний есть два свойства со значениями по умолчанию:
* state – moderating
* createdAt – текущая дата

```
make('Hexlet', { website: 'hexlet.io', state: 'published' });
// {
//   name: 'Hexlet',
//   website: 'hexlet.io',
//   state: 'published',
//   createdAt: <тут текущая дата>
// }
```

### getSortedNames
Реализуйте и экспортируйте по умолчанию функцию, которая принимает на вход список пользователей, извлекает их имена, сортирует в алфавитном порядке и возвращает отсортированный список имен.

```
const users = [
  { name: 'Bronn', gender: 'male', birthday: '1973-03-23' },
  { name: 'Reigar', gender: 'male', birthday: '1973-11-03' },
  { name: 'Eiegon', gender: 'male', birthday: '1963-11-03' },
  { name: 'Sansa', gender: 'female', birthday: '2012-11-03' },
];

getSortedNames(users); // ['Bronn', 'Eiegon', 'Reigar', 'Sansa']
```

### fromPairs
Реализуйте и экспортируйте функцию по умолчанию, которая принимает на вход массив, состоящий из массивов-пар и возвращает объект, полученный из этих пар.

Если при конструировании объекта попадаются совпадающие ключи, то берётся значение из последнего массива-пары:

```
fromPairs([['cat', 5], ['dog', 6], ['cat', 11]])
// { 'cat': 11, 'dog': 6 }
```

Примеры:

```
fromPairs([['fred', 30], ['barney', 40]]);
// { 'fred': 30, 'barney': 40 }
```

### bqs
Реализуйте и экспортируйте функцию, которая принимает на вход список параметров и возвращает сформированный query string из этих параметров:

```
bqs({ per: 10, page: 1 });
// page=1&per=10

bqs({ param: 'all', param1: true });
// param=all&param1=true
```

Имена параметров в выходной строке должны располагаться в алфавитном порядке (то есть их нужно отсортировать).

### genDiff
Реализуйте и экспортируйте по умолчанию функцию, которая сравнивает два объекта и возвращает результат сравнения в виде объекта. Ключами результирующего объекта будут все ключи из двух входящих объектов, а значением строка с описанием отличий: added, deleted, changed или unchanged.

Возможные значения:
* added — ключ отсутствовал в первом объекте, но был добавлен во второй
* deleted — ключ был в первом объекте, но отсутствует во втором
* changed — ключ присутствовал и в первом и во втором объектах, но значения отличаются
* unchanged — ключ присутствовал и в первом и во втором объектах с одинаковыми значениями

```
genDiff(
  { one: 'eon', two: 'two', four: true },
  { two: 'own', zero: 4, four: true },
);
// {
//   one: 'deleted',
//   two: 'changed',
//   four: 'unchanged',
//   zero: 'added',
// }
```

### findWhere
Реализуйте и экспортируйте по умолчанию функцию, которая принимает на вход массив (элементы которого — это объекты) и пары ключ-значение (тоже в виде объекта), а возвращает первый элемент исходного массива, значения которого соответствуют переданным парам (всем переданным). Если совпадений не было, то функция должна вернуть null.

```
findWhere(
  [
    { title: 'Book of Fooos', author: 'FooBar', year: 1111 },
    { title: 'Cymbeline', author: 'Shakespeare', year: 1611 },
    { title: 'The Tempest', author: 'Shakespeare', year: 1611 },
    { title: 'Book of Foos Barrrs', author: 'FooBar', year: 2222 },
    { title: 'Still foooing', author: 'FooBar', year: 3333 },
    { title: 'Happy Foo', author: 'FooBar', year: 4444 },
  ],
  { author: 'Shakespeare', year: 1611 }
); // { title: 'Cymbeline', author: 'Shakespeare', year: 1611 }
```

### scrabble
Реализуйте и экспортируйте по умолчанию функцию-предикат, которая принимает на вход два параметра: набор символов в нижнем регистре (строку) и слово, и проверяет, можно ли из переданного набора составить это слово. В результате вызова функция возвращает true или false.

При проверке учитывается количество символов, нужных для составления слова, и не учитывается их регистр.

```
scrabble('rkqodlw', 'world'); // true
scrabble('avj', 'java'); // false
scrabble('avjafff', 'java'); // true
scrabble('', 'hexlet'); // false
scrabble('scriptingjava', 'JavaScript'); // true
```

### sortByCount
Отсортировать массив по частоте встречаемости

```
const array = [1, 2, 3, 3, 4, 9, 3, 4, 4, 5, 5, 5, 5];
sortByCount(array); // [ 5, 3, 4, 1, 2, 9 ]
```