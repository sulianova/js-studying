## Object oriented programming

### getMutualFriends
Реализуйте и экспортируйте функцию getMutualFriends(), которая принимает на вход двух пользователей и возвращает массив состоящий из общих друзей этих пользователей.

Интерфейс абстракции "Пользователь":
* user.id – возвращает идентификатор пользователя, по которому можно его отличить от остальных.
* user.getFriends() – возвращает список друзей (то есть пользователей).

```
const user1 = makeUser({
  friends: [
    makeUser({ id: 1 }),
    makeUser({ id: 2 }), // общий друг
  ],
});
const user2 = makeUser({
  friends: [
    makeUser({ id: 2 }), // общий друг
    makeUser({ id: 3 }),
  ],
});
 
getMutualFriends(user1, user2); // [ { friends: [], id: 2, getFriends: [Function: getFriends] } ]

```

### rational
Реализуйте и экспортируйте по умолчанию функцию, которая создает рациональное число. Рациональное число должно быть представлено объектом со следующими методами:
* Сеттер setNumer() - устанавливает числитель
* Сеттер setDenom() - устанавливает знаменатель
* Геттер getNumer() - возвращает числитель
* Геттер getDenom() - возвращает знаменатель
* Геттер toString() - возвращает строковое представление числа
* Метод add() - складывает дробь на которой он был вызван с переданной дробью и возвращает новое рациональное число (не изменяет текущее!)

```
const rat1 = make();
rat1.setNumer(3);
rat1.setDenom(8);
rat1.getNumer(); // 3
rat1.getDenom(); // 8
 
const rat2 = make(10, 3);
 
// Формула сложения: a / b + c / d = (a * d + b * c) / (b * d)
const rat3 = rat1.add(rat2);
rat3.toString(); // '89/24'
```

### bind
Реализуйте и экспортируйте по умолчанию функцию, которая ведет себя аналогично встроенной bind(obj, fn). Аргументы функции:
* obj – объект выступающий в роли контекста
* fn() – функция привязываемая к контексту

```
const obj = { number: 5 };
const fn = function fn(number) {
  return number + this.number;
};
const fnWithContext = bind(obj, fn);
 
// Принимает столько же аргументов сколько и исходная функция
fnWithContext(3); // 8
```

### each
Реализуйте и экспортируйте функцию по умолчанию, которая принимает на вход коллекцию объектов и колбек функцию. Эта функция должна вызывать колбек для каждого объекта коллекции. Главная особенность этой функции в том, что она передает объекты коллекции не в саму функцию, а устанавливает их как контекст.

```
const objects = [
  { name: 'Karl' },
  { name: 'Mia' },
];
each(objects, function callback() {
  this.name = this.name.split('').reverse().join('');
});
 
console.log(objects);
// [
//   { name: 'lraK' },
//   { name: 'aiM' },
// ];
```

### segment
Реализуйте и экспортируйте по умолчанию функцию, которая принимает на вход отрезок и возвращает новый отрезок с точками, добавленными в обратном порядке (begin меняется местами с end).

Точки в результирующем отрезке должны быть копиями (по значению) соответствующих точек исходного отрезка. То есть они не должны быть ссылкой на один и тот же объект, так как это разные объекты (пускай и с одинаковыми координатами). Для создания копий используйте соответствующие конструкторы.

```
const beginPoint = new Point(1, 10);
const endPoint = new Point(11, -3);
 
const segment = new Segment(beginPoint, endPoint);
const reversedSegment = reverse(segment);
 
// прямое обращение к свойствам приведено только в демонстрационных целях
console.log(
  segment.beginPoint.x,
  segment.beginPoint.y,
  segment.endPoint.x,
  segment.endPoint.y,
);// => 1 10 11 -3
 
console.log(
  reversedSegment.beginPoint.x,
  reversedSegment.beginPoint.y,
  reversedSegment.endPoint.x,
  reversedSegment.endPoint.y,
); // => 11 -3 1 10
```

### money
Реализуйте и экспортируйте по умолчанию абстракцию "Деньги". Она знает о валюте денег, позволяет их конвертировать в другие валюты, выполнять арифметические операции и форматировать вывод. Список методов:
* Money(value, currency = 'usd') – создает объект-деньги.
* Money.prototype.getValue() – возвращает стоимость в виде числа
* Money.prototype.getCurrency() – возвращает валюту денег
* Money.prototype.exchangeTo(currency) – возвращает новый объект-деньги, где значение конвертировано в указанную валюту
* Money.prototype.add(money) – возвращает новый объект-деньги, который представляет из себя сумму исходных и переданных денег, в валюте исходных денег (внутри возможна конвертация если валюты не совпадают)
* Money.prototype.format() – возвращает локализованное представление денег удобное для вывода

```
const money1 = new Money(100);
 
// Возвращает значение
money1.getValue(); // 100
money1.getCurrency(); // 'usd'
 
// Конвертирует в указанную валюту и возвращает новое значение
money1.exchangeTo('eur').getValue(); // 70
 
const money2 = new Money(200, 'eur');
money2.getValue(); // 200
const money3 = money2.add(money1);
money3.getValue(); // 270
const money4 = money3.add(money1);
money4.getValue(); // 340
 
money1.format(); // "$100.00"
money2.format(); // "€200.00"
 
const money5 = new Money(10000);
money5.format(); // "$10,000.00"
```
Наша реализация поддерживает только две валюты: usd и eur без возможности расширения. Коэффициенты конверсии:
* usd -> eur = 0.7
* eur -> usd = 1.2

### magic
Реализуйте и экспортируйте по умолчанию функцию, которая работает следующим образом:
* Принимает на вход любое количество аргументов и возвращает функцию, которая, в свою очередь, принимает на вход любое количество аргументов и так до бесконечности (привет, рекурсия ;)).
* Аргументами могут быть только числа.
* Результат вызова этой функции при проверке на равенство должен быть равен сумме всех аргументов всех подфункций.

```
magic() == 0; // true
magic(5, 2, -8) == -1; // true
magic(1, 2)(3, 4, 5)(6)(7, 10) == 38; // true
magic(4, 8, 1, -1, -8)(3)(-3)(7, 2) == 13; // true
```
### toString
Реализуйте метод toString(), который преобразует точку к строке в соответствии с примером ниже (1, 10):

```
const point1 = new Point(1, 10);
console.log(point1.toString()); // => (1, 10)
```

Реализуйте метод toString(), который преобразует отрезок к строке в соответствии с примером ниже:

```
const point1 = new Point(1, 10);
const point2 = new Point(11, -3);
const segment1 = new Segment(point1, point2);
console.log(segment1.toString()); // => [(1, 10), (11, -3)]
 
const segment2 = new Segment(point2, point1);
console.log(segment2.toString()); // => [(11, -3), (1, 10)]
```

### cart
Реализуйте и экспортируйте по умолчанию класс Cart, представляющий из себя покупательскую корзину. Интерфейс:
* addItem(item, count) – добавляет в корзину товары и их количество. Товар это объект у которого два свойства: name – имя и price – стоимость.
* getItems – возвращает товары в формате [{ item, count }, { item, count }, ...]
* getCost – возвращает стоимость корзины. Общая стоимость корзины высчитывается как стоимость всех добавленных товаров с учетом их количества.
* getCount – возвращает количество товаров в корзине

```
const cart = new Cart();
cart.addItem({ name: 'car', price: 3 }, 5);
cart.addItem({ name: 'house', price: 10 }, 2);
cart.getItems().length; // 2
cart.getCost(); // 35
cart.getItems();
// [
//   { item: { name: 'car', price: 3 }, count: 5 },
//   { item: { name: 'house', price: 10 }, count: 2 },
// ]
```

### time
Класс Time, предназначен для создания объекта-времени. Его конструктор принимает на вход количество часов и минут в виде двух отдельных параметров.

```
const time = new Time(10, 15);
console.log(`The time is ${time}`); // => 'The time is 10:15'
```

Добавьте в класс Time статический метод fromString(), который позволяет создавать объекты Time на основе времени переданного строкой формата часы:минуты.

```
const time = Time.fromString('10:23');
// автоматически вызывается метод toString()
console.log(`The time is ${time}`); // 'The time is 10:23'
```

### parseJson
Реализуйте и экспортируйте функцию-обёртку parseJson() для функции JSON.parse(), которая работает как встроенная. Но в случае если в функцию была передана некорректная json строка, функция должна выбросить исключение ParseError. 

```
const json = '{ "key": "value" }';
parseJson(json); // { key: 'value' }
 
const incorrectJson = '{ key": "value" }';
parseJson(incorrectJson); // => ParseError: Invalid JSON string
```

### getInvalidBooks
Реализуйте и экспортируйте по умолчанию функцию, которая принимает на вход список книг, находит среди них невалидные и возвращает их наружу.

Описания формата каждой книги:
* name – строка, обязательное
* author – строка, обязательное
* pagesCount – положительное число, необязательное
* link – строка url, необязательное, не может быть пустой строкой; ссылка на книгу в интернете
* genre – строка, необязательное; жанр книги. Должен входить в список определенный в файле index.js

Пример:
```
const books = [
  { name: 'book', author: 'author' },
  { author: 'author 2' },
];
const invalidBooks = getInvalidBooks(books); // [{ author: 'author 2' }]
```

### normalize
Реализуйте и экспортируйте по умолчанию функцию normalize() которая принимает на вход список городов и стран, нормализует их имена, сортирует города и группирует их по стране.

Пример:
```
const countries = [
  { name: 'Miami', country: 'usa' },
  { name: 'samarA', country: '  ruSsiA' },
  { name: 'Moscow ', country: ' Russia' },
];

normalize(countries);
// {
//   russia: [
//     'moscow',
//     'samara',
//   ],
//   usa: [
//     'miami',
//   ],
// }
```
### node
Двоичное дерево поиска состоит из узлов, каждый из которых содержит значение ключа и два поддерева (левое и правое), которые в свою очередь также являются двоичными деревьями. Правильное дерево не содержит повторяющихся ключей, и для каждого узла гарантируется, что в левом поддереве все значения меньше текущего, а в правом — больше.

Реализуйте и экспортируйте по умолчанию класс, который реализует представление узла. Конструктор класса принимает на вход значение ключа (число), и двух детей, которые в свою очередь также являются узлами. Дерево может быть создано пустым.

Класс должен содержать методы:
* Геттер getKey() — возвращает ключ. Если дерево пустое, возвращает null.
* Геттеры getLeft(), getRight() — возвращают соответственно левого и правого ребёнка. Если ребёнок в узле отсутствует, геттер возвращает null.
* search(key) — выполняет поиск узла в правильном двоичном дереве по ключу и возвращает узел. Если узел не найден, возвращается null.

```
const tree = new Node(9,
  new Node(4,
    new Node(3),
    new Node(6,
      new Node(5),
      new Node(7))),
  new Node(17,
    null,
    new Node(22,
      new Node(20),
      null)));

const node = tree.search(6);
node.getKey(); // 6
node.getLeft().getKey(); // 5
node.getRight().getKey(); // 7

tree.search(35); // null
tree.search(3).getLeft(); // null
```